#include "can_tx.h"     // header for our CAN TX API (modes, batt enums, prototype)
#include "usart.h"      // for printf UART debug output
#include "gpio.h"       // for LED GPIO toggle (LD2 pin)
#include <string.h>     // for memset
#include <stdio.h>      // for printf
#include <stdbool.h>    // for bool type
#include <math.h>       // for lrintf()
#include "can_400HYP.h"
#include "can_400DZB.h"
#include "can_400ST.h"
#include "../Inc/can_600.h"
#include "../Inc/can_500BMZ.h"
#include "../Inc/can_500HYP.h"

/*
 * GOAL OF THIS FILE
 * -----------------
 * This module simulates the CAN traffic produced by different battery packs
 * so it looks "real" to the receiver (COTEK4AOs).
 *
 * The receiver:
 *   - identifies what battery type it is talking to
 *   - reads max/min cell voltage, pack voltage, SoC, temps, and error codes
 *   - classifies the battery as OPERATIONAL / RECOVERABLE / NON-RECOVERABLE
 *
 * IMPORTANT CHANGES (per request):
 *   - We DO NOT transmit the internal "mode" anywhere on the bus anymore.
 *     Any byte that used to carry mode is now set to 0x00.
 *   - Telemetry for each Battery × Mode is now driven by explicit profiles
 *     that match your exact specification (hi/lo cell V, SoC, error code).
 *
 * METADATA BYTES (for the AO parser):
 *   - battery_type_code (16-bit): lets AO identify the pack type
 *   - last_error_code   (8-bit):  family-dependent NR trigger (if nonzero)
 *
 * Lines containing those are marked with:
 *      ***** IMPORTANT TO AO *****
 */

/* ---- Debug print macro --------------------------------------------------- */
#define CAN_DBG(...) do { printf(__VA_ARGS__); } while (0)

/* ---- CAN handle from HAL (generated by CubeMX) --------------------------- */
extern CAN_HandleTypeDef hcan1; // declared in can.c by CubeMX (global)

/* ---- Internal simulator state ------------------------------------------- */
static uint8_t  g_battType = 0U; /* which battery the UI selected (0..5)      */
static uint8_t  g_mode     = 0U; /* internal mode we selected:
                                    0=Operational,
                                    1=Recoverable,
                                    2=NonRecoverable                         */
static uint32_t fakeMs     = 0U; /* simulated "time in ms" (we manually tick) */
static uint32_t lastSendMs = 0U; /* last ms timestamp we sent periodic CAN    */
static uint32_t lastBlinkMs= 0U; /* last ms timestamp we toggled the LED      */

/* Blink interval: toggle LED every 125ms -> 8 toggles/sec -> 4Hz blink
 * (because a full on->off->on cycle takes 250ms ~ 4 per second)             */
#define CAN_BLINK_INTERVAL_MS   125U

// Flags for the injection of the faults
static bool g_injectWarnActive = false;  // true => keep sending 0x501 every tick
static bool g_injectCritActive = false;  // true => keep sending 0x502 every tick

#define HYP400_NODE_ID   0x00u  /* change to 0x01,0x02... if you want multiple 400s on the bus */

/* small per-family tickers (we reuse fakeMs, so we just keep last-send times) */
static uint32_t last400_fast_ms = 0U;   /* for 0x180608.. + 0x180708.. (100 ms) */
static uint32_t last400_slow_ms = 0U;   /* for 0x180C08.. + 0x18040A.. (1000 ms) */

// UI hooks for injection toggles
void CAN_TX_SetNonCriticalActive(bool active) { g_injectWarnActive = active; }
void CAN_TX_SetCriticalActive(bool active)    { g_injectCritActive = active; }

/* ---- Battery "families" -------------------------------------------------- */
typedef enum {
    FAM_600S = 0,        // Custom Power / "600s" CAN format
    FAM_500S_HYPER,      // 500s Hyperdrive (J1939-ish 0x18FF...)
    FAM_500S_BMZ,        // 500s BMZ / Custom Power style (0x10000010...)
    FAM_400S_HYPER,      // 400s Hyperdrive
    FAM_400S_DUALZ,      // 400s Dual Zone variant
    FAM_400S_STEAT,      // 400s Steatite / Chill-only
    FAM_COUNT            // sentinel
} BattFam;

/* Per battery static info */
typedef struct {
    uint8_t  cells;      // series cells
    BattFam  fam;        // family / protocol
    uint16_t type_code;  // ***** IMPORTANT TO AO ***** battery_type_code
} BattInfo_t;

/* battInfoTable index MUST match your UI enum in can_tx.h:
 *   0=BATT_600S
 *   1=BATT_500S_HYPER
 *   2=BATT_500S_BMZ
 *   3=BATT_400S_HYPER
 *   4=BATT_400S_DUALZ
 *   5=BATT_400S_STEAT
 */
static const BattInfo_t battInfoTable[BATT_COUNT] = {
    /* 0: 600s */
    {13, FAM_600S,       0x0600},
    /* 1: 500s Hyperdrive */
    {12, FAM_500S_HYPER, 0x0500},
    /* 2: 500s BMZ */
    {13, FAM_500S_BMZ,   0x0501},
    /* 3: 400s Hyperdrive */
    { 6, FAM_400S_HYPER, 0x0400},
    /* 4: 400s Dual-Zone */
    { 6, FAM_400S_DUALZ, 0x0401},
    /* 5: 400s Steatite */
    { 6, FAM_400S_STEAT, 0x0402},
};

/* ===== Explicit profiles for each Battery × Mode (matches your spec) ===== */
typedef struct {
    float   hi_V;
    float   lo_V;
    uint8_t soc_pct;
    uint8_t last_err;   // family-specific NonRec code; 0 when none
} BattModeProfile;

/* Indexing: [battery][mode]
 * battery: 0=600s, 1=500s Hyper, 2=500s BMZ, 3=400s Hyper, 4=400s DualZ, 5=400s Steat
 * mode:    0=Operational, 1=Recoverable, 2=NonRecoverable
 */
static const BattModeProfile kProfiles[BATT_COUNT][MODE_COUNT] = {
    /* 0) 600s (13s), Family A, type_code=0x0600 */
    {
        /* Operational  */ { 4.05f, 4.02f, 90, 0x00 },
        /* Recoverable  */ { 3.60f, 3.55f, 50, 0x00 },
        /* NonRec      */ { 1.85f, 1.80f,  5, 0x01 },
    },
    /* 1) 500s Hyper (12s), Family B, type_code=0x0500 */
    {
        /* Operational  */ { 4.05f, 4.02f, 90, 0x00 },
        /* Recoverable  */ { 3.60f, 3.55f, 50, 0x00 },
        /* NonRec      */ { 2.80f, 2.60f,  5, 0x02 },
    },
    /* 2) 500s BMZ (13s), Family A, type_code=0x0501 */
    {
        /* Operational  */ { 3.95f, 3.90f, 90, 0x00 },
        /* Recoverable  */ { 3.60f, 3.55f, 50, 0x00 },
        /* NonRec      */ { 2.32f, 2.30f,  5, 0x0C },
    },
    /* 3) 400s Hyper (6s), Family C, type_code=0x0400 */
    {
        /* Operational  */ { 4.10f, 4.05f, 90, 0x00 },
        /* Recoverable  */ { 3.60f, 3.55f, 50, 0x00 },
        /* NonRec      */ { 2.70f, 2.50f,  5, 0x00 },
    },
    /* 4) 400s Dual-Zone (6s), Family C, type_code=0x0401 */
    {
        /* Operational  */ { 4.10f, 4.05f, 90, 0x00 },
        /* Recoverable  */ { 3.60f, 3.55f, 50, 0x00 },
        /* NonRec      */ { 2.50f, 2.45f,  5, 0x00 },
    },
    /* 5) 400s Steatite (6s), Family C, type_code=0x0402 */
    {
        /* Operational  */ { 4.10f, 4.05f, 90, 0x00 },
        /* Recoverable  */ { 3.60f, 3.55f, 50, 0x00 },
        /* NonRec      */ { 2.50f, 2.30f,  5, 0x00 },
    },
};

/* ---- chooseTelemetryForMode ---------------------------------------------- */
static TelemetryOut chooseTelemetryForMode(uint8_t battIdx, uint8_t modeIdx)
{
    TelemetryOut t;
    memset(&t, 0, sizeof(t));

    /* Temps fixed (as before) */
    const int16_t tHigh10 = (int16_t)(30.0f * 10.0f); // 30.0°C
    const int16_t tLow10  = (int16_t)(28.0f * 10.0f); // 28.0°C

    /* Clamp indexes */
    if (battIdx >= BATT_COUNT) battIdx = 0;
    if (modeIdx >= MODE_COUNT) modeIdx = MODE_OPERATIONAL;

    const BattModeProfile *p = &kProfiles[battIdx][modeIdx];

    /* Copy from profile */
    t.highCell_V      = p->hi_V;
    t.lowCell_V       = p->lo_V;
    t.soc_pct         = p->soc_pct;
    t.last_error_code = p->last_err;
    t.tempHigh_0p1C   = tHigh10;
    t.tempLow_0p1C    = tLow10;

    /* Compute pack voltage from cell avg × number of series cells */
    const float avg   = 0.5f * (t.highCell_V + t.lowCell_V);
    const uint8_t cs  = battInfoTable[battIdx].cells;
    t.pack_V          = avg * (float)cs;

    return t;
}

/* ---- CAN helpers ---------------------------------------------------------- */
void CAN_TX_SendStd(uint32_t canId, const uint8_t *data, uint8_t dlc)
{
    CAN_TxHeaderTypeDef hdr;
    uint32_t mailbox;

    hdr.StdId = canId & 0x7FFu;
    hdr.ExtId = 0;
    hdr.IDE   = CAN_ID_STD;
    hdr.RTR   = CAN_RTR_DATA;
    hdr.DLC   = dlc;
    hdr.TransmitGlobalTime = DISABLE;

    (void)HAL_CAN_AddTxMessage(&hcan1, &hdr, (uint8_t*)data, &mailbox);

    if (HAL_CAN_AddTxMessage(&hcan1, &hdr, (uint8_t*)data, &mailbox) == HAL_OK) {
        CAN_DBG("[CAN] STD 0x%03lX DLC=%u OK\r\n",
                (unsigned long)canId, dlc);
    } else {
        CAN_DBG("[CAN] STD 0x%03lX FAIL\r\n", (unsigned long)canId);
    }
}

void CAN_TX_SendExt(uint32_t canIdExt, const uint8_t *data, uint8_t dlc)
{
    CAN_TxHeaderTypeDef hdr;
    uint32_t mailbox;

    hdr.StdId = 0;
    hdr.ExtId = canIdExt & 0x1FFFFFFFu;
    hdr.IDE   = CAN_ID_EXT;
    hdr.RTR   = CAN_RTR_DATA;
    hdr.DLC   = dlc;
    hdr.TransmitGlobalTime = DISABLE;

    (void)HAL_CAN_AddTxMessage(&hcan1, &hdr, (uint8_t*)data, &mailbox);

    if (HAL_CAN_AddTxMessage(&hcan1, &hdr, (uint8_t*)data, &mailbox) == HAL_OK) {
        CAN_DBG("[CAN] EXT 0x%08lX DLC=%u OK\r\n",
                (unsigned long)canIdExt, dlc);
    } else {
        CAN_DBG("[CAN] EXT 0x%08lX FAIL\r\n",
                (unsigned long)canIdExt);
    }
}

/* ---- LED blink while active ---------------------------------------------- */
static void canBlink(uint32_t nowMs)
{
    if ((nowMs - lastBlinkMs) >= CAN_BLINK_INTERVAL_MS) {
        lastBlinkMs = nowMs;
        HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
    }
}

/* Fault injection frames: keep, but do NOT include mode (set 0) */
void CAN_TX_SendNonCritical(void)
{
    uint8_t d[8] = {0};

    d[0] = 0x55;          // marker for "warning"
    d[1] = g_battType;    // which batt type is active
    d[2] = 0x00;          // (was mode) -> now 0
    d[3] = 0x01;          // warning code / severity level

    CAN_TX_SendStd(0x501u, d, 8);
}

void CAN_TX_SendCritical(void)
{
    uint8_t d[8] = {0};

    d[0] = 0xEE;          // marker for "critical fault"
    d[1] = g_battType;    // batt
    d[2] = 0x00;          // (was mode) -> now 0
    d[3] = 0xFF;          // critical code / severity level

    CAN_TX_SendStd(0x502u, d, 8);
}

/* ---- sendFamilyFrames ---------------------------------------------------- */
static void sendFamilyFrames(uint8_t battIdx,
                             const TelemetryOut *T,
                             uint32_t nowMs)
{
    if (battIdx >= BATT_COUNT) return;

    switch (battInfoTable[battIdx].fam) {
        case FAM_600S:
            CAN_600_Tick(T, nowMs);
            break;

        case FAM_500S_BMZ:
            CAN_500BMZ_Tick(T, nowMs,false);
            break;

        case FAM_500S_HYPER:
            CAN_500HYP_Tick(T, nowMs, false);
            break;

        case FAM_400S_HYPER:
            /* new, goes to separate file */
            CAN_400HYP_Tick(T, nowMs);
            break;

        case FAM_400S_DUALZ:
            CAN_400DZB_Tick(T, nowMs, false);
            break;

        case FAM_400S_STEAT:
            CAN_400ST_Tick(T, nowMs);
            break;

        default:
            break;
    }
}
/* ---------------------------------------------------------------------------
 * PUBLIC FUNCTIONS
 * ------------------------------------------------------------------------- */

void CAN_TX_Init(void)
{
    CAN_FilterTypeDef f;
    memset(&f, 0, sizeof(f));

    f.FilterBank = 0;
    f.FilterMode = CAN_FILTERMODE_IDMASK;
    f.FilterScale = CAN_FILTERSCALE_32BIT;
    f.FilterIdHigh      = 0x0000;
    f.FilterIdLow       = 0x0000;
    f.FilterMaskIdHigh  = 0x0000;
    f.FilterMaskIdLow   = 0x0000;
    f.FilterFIFOAssignment = CAN_RX_FIFO0;
    f.FilterActivation     = ENABLE;

    if (HAL_CAN_ConfigFilter(&hcan1, &f) != HAL_OK) {
        CAN_DBG("[CAN] Filter config FAILED\r\n");
    }

    if (HAL_CAN_Start(&hcan1) != HAL_OK) {
        CAN_DBG("[CAN] Start FAILED\r\n");
    } else {
        CAN_DBG("[CAN] Started OK\r\n");
    }
    /* IMPORTANT: init ALL families so they can manage their own cadence */
    CAN_600_Init(0x00);
    CAN_500BMZ_Init(0x00);
    CAN_400DZB_Init(0x00);
    CAN_400HYP_Init(0x00);
    CAN_400DZB_Init(0x00);
    CAN_400ST_Init(0x00);

    fakeMs     = 0U;
    lastSendMs = 0U;
    lastBlinkMs= 0U;
}

void CAN_TX_SetBatteryType(uint8_t idx)
{
    if (idx < BATT_COUNT) {
        g_battType = idx;
    }
    CAN_DBG("[CAN] battType=%u fam=%u code=0x%04X\r\n",
            g_battType,
            battInfoTable[g_battType].fam,
            battInfoTable[g_battType].type_code);
}

void CAN_TX_SetMode(uint8_t idx)
{
    if (idx < MODE_COUNT) {
        g_mode = idx; // internal only (not transmitted)
    }
    CAN_DBG("[CAN] mode=%u (internal only)\r\n", g_mode);
}

/* Periodic sender (call ~every 10 ms) */
void CAN_TX_PeriodicTask(bool simActive)
{
    fakeMs += 10U;

    if (!simActive) {
        return;
    }

    /* choose the data for the currently selected battery/mode */
    TelemetryOut T = chooseTelemetryForMode(g_battType, g_mode);

    /* let the per-family sender decide what to send at this time */
    sendFamilyFrames(g_battType, &T, fakeMs);

    /* fault injections (std IDs) */
    if (g_injectWarnActive) {
        CAN_TX_SendNonCritical();
    }
    if (g_injectCritActive) {
        CAN_TX_SendCritical();
    }

    /* blink LED */
    canBlink(fakeMs);
}

