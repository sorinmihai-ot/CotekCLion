//$file${.::main.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: Cotek.qm
// File:  ${.::main.c}
//
// This code has been generated by QM 7.0.1 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::main.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "main.h"
#include "qpc_cfg.h"
#include "qpc.h"
#include <string.h>
#include <stdio.h>
#include "bsp.h"
#include "can_app.h"
#include "app_signals.h"
#include "bms_app.h"
#include "ao_nextion.h"
#include "ao_cotek.h"
#include "ao_controller.h"
#include "stm32f1xx_hal.h"
#include "stm32f1xx_hal_gpio.h"
#include "stm32f1xx_hal_i2c.h"

//Firmware Version
const char FW_VERSION_STR[] = "0.4.2";
static uint8_t nexRx[128];
/* HMI RX buffer (visible to main and callbacks) */
uint8_t s_uart3_rxbuf[128];
static uint8_t s_uart2_rxbuf[64];
extern bool BSP_qfStarted(void);

Q_DEFINE_THIS_MODULE("main") /* this module name for Q_ASSERT() */

#define COTEK_I2C_ADDR ((0x50) << 1)  // STM32 expects 8-bit address (shifted left)
#define I2C_TIMEOUT_MS 100
// 1) Pick a larger block size for UI events. 320 is a safe start.
#define UI_POOL_BLOCK_SIZE   320U
#define UI_POOL_BLOCKS       16u

typedef struct {
  uint8_t bytes[(sizeof(NextionSummaryEvt) > sizeof(NextionDetailsEvt))
                  ? sizeof(NextionSummaryEvt)
                  : sizeof(NextionDetailsEvt)];
} UiPoolMax;

_Static_assert(sizeof(NextionSummaryEvt) <= UI_POOL_BLOCK_SIZE, "UI pool too small for NextionSummaryEvt");
_Static_assert(sizeof(NextionDetailsEvt) <= UI_POOL_BLOCK_SIZE, "UI pool too small for NextionDetailsEvt");

/* Private variables ---------------------------------------------------------*/
CAN_HandleTypeDef hcan;
I2C_HandleTypeDef hi2c1;
UART_HandleTypeDef huart2;
UART_HandleTypeDef huart3;

void Scan_I2C_Bus(I2C_HandleTypeDef *hi2c);

/* Forward static CubeMX-like init */
static void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);
static void MX_CAN_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_USART3_UART_Init(void);
// 2) Make the storage big enough. If you currently have 8 blocks, keep it.
static uint8_t s_uiPoolSto[UI_POOL_BLOCK_SIZE * UI_POOL_BLOCKS];

extern QActive *AO_Cotek;

void Scan_I2C_Bus(I2C_HandleTypeDef *hi2c) {
    printf("Scanning I2C bus...\r\n");

    for (uint8_t address = 1; address < 127; address++) {
        if (HAL_I2C_IsDeviceReady(hi2c, (address << 1), 1, 100) == HAL_OK) {
            printf("I2C device found at address: 0x%02X\r\n", address);
        }
        HAL_Delay(10);
    }

    printf("I2C scan complete.\r\n");
}

int __io_putchar(int ch);
uint8_t RxBuffer[256];
uint8_t TxBuffer[] = "LED is ON \n";
uint16_t buff_size = 0;
volatile uint8_t rx_complete = 0;

static void nex_send3(const char *s) {
  static const uint8_t ff[3] = {0xFF,0xFF,0xFF};
  HAL_UART_Transmit(&huart3, (uint8_t*)s, (uint16_t)strlen(s), 200);
  HAL_UART_Transmit(&huart3, (uint8_t*)ff, 3, 200);
}
void StartHmiRx(void) {
  extern UART_HandleTypeDef huart3;
  HAL_UARTEx_ReceiveToIdle_IT(&huart3, s_uart3_rxbuf, sizeof s_uart3_rxbuf);
}

void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t len) {
  extern void Nextion_OnRx(uint8_t const *buf, uint16_t len);
  /* Gate everything until QF is live */
  if (!BSP_qfStarted()) {
    if (huart == &huart3 && len > 0U)
    {
      Nextion_OnRx(s_uart3_rxbuf, len);               // <-- use s_uart3_rxbuf
      HAL_UARTEx_ReceiveToIdle_IT(&huart3, s_uart3_rxbuf, sizeof s_uart3_rxbuf);
    }

    else if (huart == &huart2 && len > 0U) HAL_UARTEx_ReceiveToIdle_IT(&huart2, s_uart2_rxbuf, sizeof s_uart2_rxbuf);
    return;
  }
  // post-QF: (for now) just re-arm, youâ€™re not parsing HMI replies yet
  if (huart == &huart3 && len > 0U) {
    Nextion_OnRx(s_uart3_rxbuf, len);               // <-- use s_uart3_rxbuf
    HAL_UARTEx_ReceiveToIdle_IT(&huart3, s_uart3_rxbuf, sizeof s_uart3_rxbuf);
  } else if (huart == &huart2 && len > 0U) {
    HAL_UARTEx_ReceiveToIdle_IT(&huart2, s_uart2_rxbuf, sizeof s_uart2_rxbuf);
  }
}
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* --- construct AOs --- */
  NextionAO_ctor();
  ControllerAO_ctor();
  CotekAO_ctor();
  BmsAO_ctor();
   /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
  /* Ensure priorities are QP-safe *before* anything else runs */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
  /* Core exceptions used by the framework */
  NVIC_SetPriority(SysTick_IRQn, 5);
  NVIC_SetPriority(PendSV_IRQn, 5);
  NVIC_SetPriority(SVCall_IRQn, 5);

  /* Peripherals that call QP/post events */
  NVIC_SetPriority(USART2_IRQn, 5);
  NVIC_SetPriority(USART3_IRQn, 5);
  NVIC_SetPriority(EXTI15_10_IRQn, 5);
  NVIC_SetPriority(USB_HP_CAN1_TX_IRQn, 5);
  NVIC_SetPriority(USB_LP_CAN1_RX0_IRQn, 5);
  BSP_init();
  /* Configure the system clock */
  SystemClock_Config();
  NVIC_SetPriority(SysTick_IRQn, 5);
  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_I2C1_Init();
  BSP_breadcrumb('A');          // after clocks/GPIO/MX_GPIO_Init()
  MX_USART2_UART_Init();
  BSP_breadcrumb('B');
  BSP_markUart2Ready();
  BSP_breadcrumb('P');// from now on printf is allowed on UART2
  printf("main(): UART2 up\r\n");
  BSP_breadcrumb('p');
  HAL_UARTEx_ReceiveToIdle_IT(&huart2, RxBuffer, 256);
  //BSP_markUart2Ready();
  //BSP_print_banner();
  //printf("\r\nmain(): UART2 up\r\n");
  MX_USART3_UART_Init();  // for Nextion
  BSP_breadcrumb('C');
  printf("main(): UART3 up\r\n");
  //HAL_UARTEx_ReceiveToIdle_IT(&huart3, nexRx, sizeof(nexRx));
  printf("main() 1\r\n");
  uint32_t prigroup = (SCB->AIRCR >> SCB_AIRCR_PRIGROUP_Pos) & 7U;
  printf("PRIGROUP=%lu\r\n", (unsigned long)prigroup);

  //HAL_UARTEx_ReceiveToIdle_IT(&huart2, RxBuffer, 256);
  //Scan_I2C_Bus(&hi2c1);
    /* ---------------- dynamic event pools & pub/sub table --------------------*/
  static QF_MPOOL_EL(CanFrameEvt)     s_canPoolSto[64];
  static QF_MPOOL_EL(BmsTelemetryEvt) s_bmsPoolSto[32];
  static QSubscrList subscrSto[MAX_PUB_SIG];
  QF_psInit(subscrSto, Q_DIM(subscrSto));
    /* pools: smallest blocks first */
    /* initialize pools in ascending size */
  if (sizeof(s_canPoolSto[0]) <= sizeof(s_bmsPoolSto[0])) {
        QF_poolInit(s_canPoolSto, sizeof(s_canPoolSto), sizeof(s_canPoolSto[0]));
        QF_poolInit(s_bmsPoolSto, sizeof(s_bmsPoolSto), sizeof(s_bmsPoolSto[0]));
  } else {
        QF_poolInit(s_bmsPoolSto, sizeof(s_bmsPoolSto), sizeof(s_bmsPoolSto[0]));
        QF_poolInit(s_canPoolSto, sizeof(s_canPoolSto), sizeof(s_canPoolSto[0]));
  }
    /* UI pool is the largest: init it last */
  QF_poolInit(s_uiPoolSto, sizeof(s_uiPoolSto), UI_POOL_BLOCK_SIZE);
  printf("pool blocks: CAN=%lu  BMS=%lu  UI=%u\r\n",
       (unsigned long)(sizeof(s_canPoolSto) / sizeof(s_canPoolSto[0])),
       (unsigned long)(sizeof(s_bmsPoolSto) / sizeof(s_bmsPoolSto[0])),
       UI_POOL_BLOCK_SIZE);

  printf("main() 3\r\n");
  static int const qfAwarePri_compiled = QF_AWARE_ISR_CMSIS_PRI;
  printf("QP compiled aware PRI = %d\r\n", qfAwarePri_compiled);
  /* ---- FINAL NVIC LOCK (must be after all MX_* init, before QF_run) ---- */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
  NVIC_SetPriority(SysTick_IRQn, 5);
  NVIC_SetPriority(PendSV_IRQn, 5);
  NVIC_SetPriority(SVCall_IRQn, 5);
  NVIC_SetPriority(USART2_IRQn, 5);
  NVIC_SetPriority(USART3_IRQn, 5);
  NVIC_SetPriority(EXTI15_10_IRQn, 5);
  NVIC_SetPriority(USB_HP_CAN1_TX_IRQn, 5);
  NVIC_SetPriority(USB_LP_CAN1_RX0_IRQn, 5);
  BSP_dumpIRQs();
  // 1) Controller first
  static QEvt const *ctlQueueSto[64];
  QACTIVE_START(AO_Controller, 4U, ctlQueueSto, Q_DIM(ctlQueueSto), 0, 0U, 0);
  printf("main() CtlAO up\r\n");
  // 2) Nextion second
  static QEvt const *nexQueueSto[128];
  QACTIVE_START(AO_Nextion, 5U, nexQueueSto, Q_DIM(nexQueueSto), 0, 0U, 0);
  printf("main() NexAO up\r\n");
  // 3) Cotek
  static QEvt const *cotekQueueSto[64];
  QACTIVE_START(AO_Cotek, 2U, cotekQueueSto, Q_DIM(cotekQueueSto), 0, 0U, 0);
  printf("main() CotekAO up\r\n");
  // 4) BMS
  static QEvt const *bmsQueueSto[64];
  QACTIVE_START(AO_Bms, 3U, bmsQueueSto, Q_DIM(bmsQueueSto), 0, 0U, 0);
  printf("main() BmsAO up\r\n");
  /* Bring up CAN after AOs are running */
  // NOW init + start CAN (bus mode already set to NORMAL in MX_CAN_Init)
  MX_CAN_Init();
  CANAPP_InitAll();    // filter+start+activate notifs
  static QEvt const bootEvt = QEVT_INITIALIZER(BOOT_SIG);
  (void)QACTIVE_POST_X(AO_Controller, &bootEvt, 1U, 0U);
  // clear any stale pending EXTI before enabling
  __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_13);
  NVIC_ClearPendingIRQ(EXTI15_10_IRQn);

  HAL_NVIC_SetPriority(EXTI15_10_IRQn, QF_AWARE_ISR_CMSIS_PRI, 0U);
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
  HAL_UARTEx_ReceiveToIdle_IT(&huart2, RxBuffer, 256);
  printf("main() 8\r\n");
  __set_BASEPRI(0U);
  HAL_Delay(50);
  nex_send3("bkcmd=3");             HAL_Delay(20);
  nex_send3("rest");                HAL_Delay(1100);  // give HMI time to reboot
  nex_send3("page pSplash");        HAL_Delay(50);
  char verCmd[64];
  snprintf(verCmd, sizeof verCmd, "pSplash.tVer.txt=\"FW v%s\"", FW_VERSION_STR);
  nex_send3(verCmd);
  //nex_send3("pSplash.tVer.txt=\"FW v0.3.1\"");
  nex_send3("ref pSplash.tVer");
  HAL_Delay(3000);
  /* Open the CAN gate once AOs/UI are fully up and HMI has settled */
  CANAPP_EnableRx(true);
  printf("sizeof(NextionSummaryEvt)=%u  Details=%u\r\n",
       (unsigned)sizeof(NextionSummaryEvt),
       (unsigned)sizeof(NextionDetailsEvt));
  printf("QP compiled aware PRI = %d\r\n", qfAwarePri_compiled);
  return QF_run();   /* does not return */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI_DIV2;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL16;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

static void MX_GPIO_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    /* GPIO Ports Clock Enable */
    __HAL_RCC_GPIOC_CLK_ENABLE();
    __HAL_RCC_GPIOD_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();

    /*Configure GPIO pin Output Level */
    HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
    GPIO_InitStruct.Pin   = LD2_Pin;
    GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Pull  = GPIO_NOPULL;
    HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);

    /*Configure GPIO pin : B1_Pin(PC13) */
    GPIO_InitStruct.Pin = GPIO_PIN_13;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    HAL_GPIO_Init(USER_BTN_GPIO_Port, &GPIO_InitStruct);
    HAL_NVIC_SetPriority(EXTI15_10_IRQn, QF_AWARE_ISR_CMSIS_PRI+1, 0);
    HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);

}
/**
  * @brief CAN Initialization Function
  * @param None
  * @retval None
  */
static void MX_CAN_Init(void)
{
  hcan.Instance = CAN1;
  hcan.Init.Prescaler = 4;
#if defined(ENABLE_BMS_SIM)
  // simulator builds can use loopback if you also inject frames
  hcan.Init.Mode = CAN_MODE_LOOPBACK;
#else
  // real battery: must be on the actual bus
  hcan.Init.Mode = CAN_MODE_NORMAL;
#endif
  hcan.Init.SyncJumpWidth = CAN_SJW_1TQ;
  hcan.Init.TimeSeg1 = CAN_BS1_13TQ;
  hcan.Init.TimeSeg2 = CAN_BS2_2TQ;
  hcan.Init.TimeTriggeredMode = DISABLE;
  hcan.Init.AutoBusOff = ENABLE;
  hcan.Init.AutoWakeUp = ENABLE;
  hcan.Init.AutoRetransmission = ENABLE;
  hcan.Init.ReceiveFifoLocked = DISABLE;
  hcan.Init.TransmitFifoPriority = DISABLE;
  if (HAL_CAN_Init(&hcan) != HAL_OK)
  {
    Error_Handler();
  }
}
/**
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{
    __HAL_RCC_I2C1_CLK_ENABLE();
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }
}
/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{
  BSP_breadcrumb('2');
    __HAL_RCC_USART2_CLK_ENABLE();
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  BSP_breadcrumb('a');       // 2a: before HAL_UART_Init
  if (HAL_UART_Init(&huart2) != HAL_OK) {
    BSP_breadcrumb('F');   // 2F: fail before die
    BSP_die(22);           // code 22 = USART2 HAL init failed
  }
  BSP_breadcrumb('b');       // 2b: after HAL_UART_Init

  if (HAL_UARTEx_ReceiveToIdle_IT(&huart2, RxBuffer, sizeof(RxBuffer)) != HAL_OK) {
    BSP_breadcrumb('G');   // 2G: fail before die
    BSP_die(23);           // code 23 = USART2 RxToIdle failed
  }
  BSP_breadcrumb('c');       // 2c: after RxToIdle enabled
}
/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART3_UART_Init(void)
{
  __HAL_RCC_USART3_CLK_ENABLE();

  huart3.Instance = USART3;
  huart3.Init.BaudRate = 115200;
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart3) != HAL_OK) { BSP_die(32); }

  // start RX-to-idle on the HMI buffer
  (void)HAL_UARTEx_ReceiveToIdle_IT(&huart3, s_uart3_rxbuf, sizeof s_uart3_rxbuf);
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
    printf(">>> Error_Handler entered!\r\n");
  while (1)
  {
      HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
      for (volatile uint32_t i=0; i<50000; ++i) { __NOP(); }
  }
}
#ifdef USE_FULL_ASSERT

void assert_failed(uint8_t *file, uint32_t line)
{
    (void)file; (void)line;
}
#endif /* USE_FULL_ASSERT */
