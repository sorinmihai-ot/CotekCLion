//$file${.::main.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: Cotek.qm
// File:  ${.::main.c}
//
// This code has been generated by QM 7.0.1 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::main.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "main.h"
#include "qpc_cfg.h"
#include "qpc.h"
#include <string.h>
#include <stdio.h>
#include "bsp.h"
#include "can_app.h"
#include "app_signals.h"
#include "bms_app.h"
#include "ao_nextion.h"
#include "ao_cotek.h"
#include "ao_controller.h"
#include "stm32f1xx_hal.h"
#include "stm32f1xx_hal_gpio.h"
#include "stm32f1xx_hal_i2c.h"

//Firmware Version
const char FW_VERSION_STR[] = "0.3.1";
static uint8_t nexRx[128];
/* HMI RX buffer (visible to main and callbacks) */
uint8_t s_uart3_rxbuf[128];
static uint8_t s_uart2_rxbuf[64];
extern bool BSP_qfStarted(void);

Q_DEFINE_THIS_MODULE("main") /* this module name for Q_ASSERT() */

#define COTEK_I2C_ADDR ((0x50) << 1)  // STM32 expects 8-bit address (shifted left)
#define I2C_TIMEOUT_MS 100

/* Private variables ---------------------------------------------------------*/
CAN_HandleTypeDef hcan;
I2C_HandleTypeDef hi2c1;
UART_HandleTypeDef huart2;
UART_HandleTypeDef huart3;

void Scan_I2C_Bus(I2C_HandleTypeDef *hi2c);

/* Forward static CubeMX-like init */
static void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);
static void MX_CAN_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_USART3_UART_Init(void);

extern QActive *AO_Cotek;

// static void nex_send_blocking(const char *fmt, ...) {
//   extern UART_HandleTypeDef huart3;
//   uint8_t tmp[160];
//   char    buf[128];
//
//   va_list ap; va_start(ap, fmt);
//   int n = vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
//   va_end(ap);
//   if (n < 0) return;
//   if ((size_t)n >= sizeof(buf)) { buf[sizeof(buf) - 1] = '\0'; n = (int)strlen(buf); }
//
//   size_t len = (size_t)n;
//   if (len > sizeof(tmp) - 3U) len = sizeof(tmp) - 3U;
//   memcpy(tmp, buf, len);
//   tmp[len + 0U] = 0xFF;
//   tmp[len + 1U] = 0xFF;
//   tmp[len + 2U] = 0xFF;
//
//   (void)HAL_UART_Transmit(&huart3, tmp, (uint16_t)(len + 3U), 100); // 100ms timeout
// }

void Scan_I2C_Bus(I2C_HandleTypeDef *hi2c) {
    printf("Scanning I2C bus...\r\n");

    for (uint8_t address = 1; address < 127; address++) {
        if (HAL_I2C_IsDeviceReady(hi2c, (address << 1), 1, 100) == HAL_OK) {
            printf("I2C device found at address: 0x%02X\r\n", address);
        }
        HAL_Delay(10);
    }

    printf("I2C scan complete.\r\n");
}

int __io_putchar(int ch);
uint8_t RxBuffer[256];
uint8_t TxBuffer[] = "LED is ON \n";
uint16_t buff_size = 0;
volatile uint8_t rx_complete = 0;

static void nex_send3(const char *s) {
  static const uint8_t ff[3] = {0xFF,0xFF,0xFF};
  HAL_UART_Transmit(&huart3, (uint8_t*)s, (uint16_t)strlen(s), 200);
  HAL_UART_Transmit(&huart3, (uint8_t*)ff, 3, 200);
}
void StartHmiRx(void) {
  extern UART_HandleTypeDef huart3;
  HAL_UARTEx_ReceiveToIdle_IT(&huart3, s_uart3_rxbuf, sizeof s_uart3_rxbuf);
}

void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t len) {
  /* Gate everything until QF is live */
  if (!BSP_qfStarted()) {
    if (huart == &huart3) HAL_UARTEx_ReceiveToIdle_IT(&huart3, s_uart3_rxbuf, sizeof s_uart3_rxbuf);
    else if (huart == &huart2) HAL_UARTEx_ReceiveToIdle_IT(&huart2, s_uart2_rxbuf, sizeof s_uart2_rxbuf);
    return;
  }
  // post-QF: (for now) just re-arm, you’re not parsing HMI replies yet
  if (huart == &huart3) {
    HAL_UARTEx_ReceiveToIdle_IT(&huart3, s_uart3_rxbuf, sizeof s_uart3_rxbuf);
  } else if (huart == &huart2) {
    HAL_UARTEx_ReceiveToIdle_IT(&huart2, s_uart2_rxbuf, sizeof s_uart2_rxbuf);
  }
}
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* --- construct AOs --- */
  NextionAO_ctor();
  ControllerAO_ctor();
  CotekAO_ctor();
  BmsAO_ctor();
   /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
  /* Ensure priorities are QP-safe *before* anything else runs */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
  /* Core exceptions used by the framework */
  NVIC_SetPriority(SysTick_IRQn, 5);
  NVIC_SetPriority(PendSV_IRQn, 5);
  NVIC_SetPriority(SVCall_IRQn, 5);

  /* Peripherals that call QP/post events */
  NVIC_SetPriority(USART2_IRQn, 5);
  NVIC_SetPriority(USART3_IRQn, 5);
  NVIC_SetPriority(EXTI15_10_IRQn, 5);
  NVIC_SetPriority(USB_HP_CAN1_TX_IRQn, 5);
  NVIC_SetPriority(USB_LP_CAN1_RX0_IRQn, 5);
  BSP_init();
  /* Configure the system clock */
  SystemClock_Config();
  NVIC_SetPriority(SysTick_IRQn, 5);
  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_I2C1_Init();
  BSP_breadcrumb('A');          // after clocks/GPIO/MX_GPIO_Init()
  MX_USART2_UART_Init();
  BSP_breadcrumb('B');
  BSP_markUart2Ready();
  BSP_breadcrumb('P');// from now on printf is allowed on UART2
  printf("main(): UART2 up\r\n");
  BSP_breadcrumb('p');
  HAL_UARTEx_ReceiveToIdle_IT(&huart2, RxBuffer, 256);
  //BSP_markUart2Ready();
  //BSP_print_banner();
  //printf("\r\nmain(): UART2 up\r\n");
  MX_USART3_UART_Init();  // for Nextion
  BSP_breadcrumb('C');
  printf("main(): UART3 up\r\n");
  //HAL_UARTEx_ReceiveToIdle_IT(&huart3, nexRx, sizeof(nexRx));
  MX_CAN_Init();
  printf("main() 1\r\n");
  uint32_t prigroup = (SCB->AIRCR >> SCB_AIRCR_PRIGROUP_Pos) & 7U;
  printf("PRIGROUP=%lu\r\n", (unsigned long)prigroup);

  //HAL_UARTEx_ReceiveToIdle_IT(&huart2, RxBuffer, 256);
  //Scan_I2C_Bus(&hi2c1);
    /* ---------------- dynamic event pools & pub/sub table --------------------*/
  static QF_MPOOL_EL(CanFrameEvt)     s_canPoolSto[64];
  static QF_MPOOL_EL(BmsTelemetryEvt) s_bmsPoolSto[32];
    /* NEW: UI pool for NextionSummaryEvt (big struct ~200+ bytes).
   8 blocks is usually plenty; tune as needed. */
  static QF_MPOOL_EL(NextionSummaryEvt) uiPoolSto[8];
  static QSubscrList subscrSto[MAX_PUB_SIG];
  QF_psInit(subscrSto, Q_DIM(subscrSto));
    /* helpful print to see sizes on UART */
  printf("pool blocks: CAN=%u  BMS=%u  UI=%u\r\n",
       (unsigned)sizeof(s_canPoolSto[0]),
       (unsigned)sizeof(s_bmsPoolSto[0]),
       (unsigned)sizeof(uiPoolSto[0]));
    /* pools: smallest blocks first */
    /* initialize pools in ascending size */
  if (sizeof(s_canPoolSto[0]) <= sizeof(s_bmsPoolSto[0])) {
        QF_poolInit(s_canPoolSto, sizeof(s_canPoolSto), sizeof(s_canPoolSto[0]));
        QF_poolInit(s_bmsPoolSto, sizeof(s_bmsPoolSto), sizeof(s_bmsPoolSto[0]));
  } else {
        QF_poolInit(s_bmsPoolSto, sizeof(s_bmsPoolSto), sizeof(s_bmsPoolSto[0]));
        QF_poolInit(s_canPoolSto, sizeof(s_canPoolSto), sizeof(s_canPoolSto[0]));
  }
    /* UI pool is the largest: init it last */
  QF_poolInit(uiPoolSto, sizeof(uiPoolSto), sizeof(uiPoolSto[0]));
  HAL_Delay(50);

  nex_send3("rest");          // 1) hard reset panel
  HAL_Delay(500);            //    allow full reboot (many panels need >1s)

  nex_send3("bkcmd=3");       // 2) verbose replies (helps later if you read RX)
  HAL_Delay(20);

  nex_send3("page pSplash");  // 3) guarantee we’re on splash
  HAL_Delay(200);             //    give the page time to load

  /* 4) finally write the version line */
  // char verCmd[64];
  // snprintf(verCmd, sizeof verCmd, "pSplash.tVer.txt=\"FW v%s\"", FW_VERSION_STR);
  // nex_send3(verCmd);
  nex_send3("tVer.txt=\"FW v0.3.1\"");
  HAL_Delay(50);
  printf("main() 3\r\n");
  static int const qfAwarePri_compiled = QF_AWARE_ISR_CMSIS_PRI;
  printf("QP compiled aware PRI = %d\r\n", qfAwarePri_compiled);
  /* ---- FINAL NVIC LOCK (must be after all MX_* init, before QF_run) ---- */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
  NVIC_SetPriority(SysTick_IRQn, 5);
  NVIC_SetPriority(PendSV_IRQn, 5);
  NVIC_SetPriority(SVCall_IRQn, 5);
  NVIC_SetPriority(USART2_IRQn, 5);
  NVIC_SetPriority(USART3_IRQn, 5);
  NVIC_SetPriority(EXTI15_10_IRQn, 5);
  NVIC_SetPriority(USB_HP_CAN1_TX_IRQn, 5);
  NVIC_SetPriority(USB_LP_CAN1_RX0_IRQn, 5);
  BSP_dumpIRQs();
  // 1) Controller first
  static QEvt const *ctlQueueSto[64];
  QACTIVE_START(AO_Controller, 4U, ctlQueueSto, Q_DIM(ctlQueueSto), 0, 0U, 0);
  printf("main() CtlAO up\r\n");
  // 2) Nextion second
  static QEvt const *nexQueueSto[32];
  QACTIVE_START(AO_Nextion, 1U, nexQueueSto, Q_DIM(nexQueueSto), 0, 0U, 0);
  printf("main() NexAO up\r\n");
  // 3) Cotek
  static QEvt const *cotekQueueSto[16];
  QACTIVE_START(AO_Cotek, 2U, cotekQueueSto, Q_DIM(cotekQueueSto), 0, 0U, 0);
  printf("main() CotekAO up\r\n");
  // 4) BMS
  static QEvt const *bmsQueueSto[64];
  QACTIVE_START(AO_Bms, 3U, bmsQueueSto, Q_DIM(bmsQueueSto), 0, 0U, 0);
  printf("main() BmsAO up\r\n");
  /* Bring up CAN after AOs are running */
  static QEvt const bootEvt = QEVT_INITIALIZER(BOOT_SIG);
  (void)QACTIVE_POST_X(AO_Controller, &bootEvt, 0U, 0U);
  // clear any stale pending EXTI before enabling
  __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_13);
  NVIC_ClearPendingIRQ(EXTI15_10_IRQn);

  HAL_NVIC_SetPriority(EXTI15_10_IRQn, QF_AWARE_ISR_CMSIS_PRI, 0U);
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
  HAL_UARTEx_ReceiveToIdle_IT(&huart2, RxBuffer, 256);
  printf("main() 8\r\n");
  __set_BASEPRI(0U);
  printf("QP compiled aware PRI = %d\r\n", qfAwarePri_compiled);
  return QF_run();   /* does not return */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI_DIV2;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL16;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

static void MX_GPIO_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    /* GPIO Ports Clock Enable */
    __HAL_RCC_GPIOC_CLK_ENABLE();
    __HAL_RCC_GPIOD_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();

    /*Configure GPIO pin Output Level */
    HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
    GPIO_InitStruct.Pin   = LD2_Pin;
    GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Pull  = GPIO_NOPULL;
    HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);

    /*Configure GPIO pin : B1_Pin(PC13) */
    GPIO_InitStruct.Pin = USER_BTN_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    HAL_GPIO_Init(USER_BTN_GPIO_Port, &GPIO_InitStruct);


}
/**
  * @brief CAN Initialization Function
  * @param None
  * @retval None
  */
static void MX_CAN_Init(void)
{
  hcan.Instance = CAN1;
  hcan.Init.Prescaler = 4;
  hcan.Init.Mode = CAN_MODE_NORMAL;
  hcan.Init.SyncJumpWidth = CAN_SJW_1TQ;
  hcan.Init.TimeSeg1 = CAN_BS1_13TQ;
  hcan.Init.TimeSeg2 = CAN_BS2_2TQ;
  hcan.Init.TimeTriggeredMode = DISABLE;
  hcan.Init.AutoBusOff = ENABLE;
  hcan.Init.AutoWakeUp = ENABLE;
  hcan.Init.AutoRetransmission = ENABLE;
  hcan.Init.ReceiveFifoLocked = DISABLE;
  hcan.Init.TransmitFifoPriority = DISABLE;
  if (HAL_CAN_Init(&hcan) != HAL_OK)
  {
    Error_Handler();
  }
}
/**
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{
    __HAL_RCC_I2C1_CLK_ENABLE();
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }
}
/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{
  BSP_breadcrumb('2');
    __HAL_RCC_USART2_CLK_ENABLE();
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  BSP_breadcrumb('a');       // 2a: before HAL_UART_Init
  if (HAL_UART_Init(&huart2) != HAL_OK) {
    BSP_breadcrumb('F');   // 2F: fail before die
    BSP_die(22);           // code 22 = USART2 HAL init failed
  }
  BSP_breadcrumb('b');       // 2b: after HAL_UART_Init

  if (HAL_UARTEx_ReceiveToIdle_IT(&huart2, RxBuffer, sizeof(RxBuffer)) != HAL_OK) {
    BSP_breadcrumb('G');   // 2G: fail before die
    BSP_die(23);           // code 23 = USART2 RxToIdle failed
  }
  BSP_breadcrumb('c');       // 2c: after RxToIdle enabled
}
/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART3_UART_Init(void)
{
  __HAL_RCC_USART3_CLK_ENABLE();

  huart3.Instance = USART3;
  huart3.Init.BaudRate = 115200;
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart3) != HAL_OK) { BSP_die(32); }

  // start RX-to-idle on the HMI buffer
  (void)HAL_UARTEx_ReceiveToIdle_IT(&huart3, s_uart3_rxbuf, sizeof s_uart3_rxbuf);
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
    printf(">>> Error_Handler entered!\r\n");
  while (1)
  {
      HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
      for (volatile uint32_t i=0; i<50000; ++i) { __NOP(); }
  }
}
#ifdef USE_FULL_ASSERT

void assert_failed(uint8_t *file, uint32_t line)
{
    (void)file; (void)line;
}
#endif /* USE_FULL_ASSERT */
